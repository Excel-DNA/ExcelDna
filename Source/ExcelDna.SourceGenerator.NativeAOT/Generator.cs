using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace ExcelDna.SourceGenerator.NativeAOT
{
    [Generator]
    public class Generator : ISourceGenerator
    {
        class TypeInfo
        {
            public ITypeSymbol Type { get; }
            public IEnumerable<IMethodSymbol> Methods { get; }

            public TypeInfo(ITypeSymbol type, IEnumerable<IMethodSymbol> methods)
            {
                this.Type = type;
                this.Methods = methods;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.PublishAOT", out string? publishAOT);

            const string regHost = "ExcelDna.Registration.StaticRegistration";
            string source = """
// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#nullable enable

namespace ExcelDna.SourceGenerator.NativeAOT
{
    [DIRECT-MARSHAL-TYPE-ADAPTER]

    public unsafe class AddInInitialize
    {
        [UnmanagedCallersOnly(EntryPoint = "Initialize", CallConvs = new[] { typeof(CallConvCdecl) })]
        public static short Initialize(void* xlAddInExportInfoAddress, void* hModuleXll, void* pPathXLL, byte disableAssemblyContextUnload, void* pTempDirPath)
        {
            [ADDINS]

[FUNCTIONS]

[ASSEMBLY-ATTRIBUTES]

[PARAMETER-CONVERSIONS]

[RETURN-CONVERSIONS]

[EXECUTION-HANDLERS]

            ExcelDna.Registration.StaticRegistration.DirectMarshalTypeAdapter = new DirectMarshalTypeAdapter();

            return ExcelDna.ManagedHost.AddInInitialize.InitializeNativeAOT(xlAddInExportInfoAddress, hModuleXll, pPathXLL, disableAssemblyContextUnload, pTempDirPath);
        }
    }
}
""";
            {
                string addIns = "";
                foreach (var i in receiver.AddIns)
                {
                    if (string.IsNullOrWhiteSpace(addIns))
                        addIns = "List<Type> interfaceRefs = new List<Type>();\r\n";

                    string actions = "";
                    foreach (var m in i.Methods)
                    {
                        if (actions.Length > 0)
                            actions += ",\r\n";
                        actions += $"typeof({Util.GetFullTypeName(m.ContainingType)}).GetMethod(\"{m.Name}\")!";
                    }

                    addIns += $"{regHost}.ExcelAddIns.Add(new ExcelDna.Integration.TypeHelper<{Util.GetFullTypeName(i.Type)}>([{actions}]));\r\n";
                    addIns += $"interfaceRefs.Add(typeof({Util.GetFullTypeName(i.Type)}).GetInterface(\"ExcelDna.Integration.IExcelAddIn\"));\r\n";
                    addIns += $"interfaceRefs.Add(typeof({Util.GetFullTypeName(i.Type)}).GetInterface(\"ExcelDna.Integration.CustomUI.IExcelRibbon\"));\r\n";
                }
                source = source.Replace("[ADDINS]", addIns);
            }
            {
                string functions = "List<Type> typeRefs = new List<Type>();\r\n";
                string methods = "List<MethodInfo> methodRefs = new List<MethodInfo>();\r\n";
                foreach (var i in receiver.Functions.Concat(receiver.Commands))
                {
                    functions += $"{regHost}.MethodsForRegistration.Add({GetMethod(i)});\r\n";
                    functions += $"typeRefs.Add(typeof({Util.MethodType(i)}));\r\n";
                    foreach (var p in i.Parameters)
                    {
                        functions += $"typeRefs.Add(typeof(Func<object, {Util.GetFullTypeName(p.Type)}>));\r\n";
                    }

                    if (i.Parameters.Length > 0 && i.Parameters.Last().IsParams && i.Parameters.Last().Type is IArrayTypeSymbol arrayType)
                    {
                        methods += $"methodRefs.Add(typeof(List<{Util.GetFullTypeName(arrayType.ElementType)}>).GetMethod(\"ToArray\")!);\r\n";
                        methods += $"methodRefs.Add(typeof(List<{Util.GetFullTypeName(arrayType.ElementType)}>).GetMethod(\"Add\")!);\r\n";
                        functions += $"typeRefs.Add(typeof(Func<{Util.CreateFunc16Args(i)}>));\r\n";
                    }

                    functions += "\r\n";
                }
                source = source.Replace("[FUNCTIONS]", functions + methods);
            }
            {
                string assemblyAttributes = "";
                foreach (AttributeData a in context.Compilation.Assembly.GetAttributes())
                {
                    if (a.AttributeClass == null || a.ConstructorArguments.Length != 1)
                        continue;

                    if (a.ConstructorArguments[0].Value is ITypeSymbol arg)
                        assemblyAttributes += $"{regHost}.AssemblyAttributes.Add(new {Util.GetFullTypeName(a.AttributeClass)}(typeof({Util.GetFullTypeName(arg)})));\r\n";
                }

                source = source.Replace("[ASSEMBLY-ATTRIBUTES]", assemblyAttributes);
            }
            {
                string parameterConversions = "";
                foreach (var i in receiver.ParameterConversions)
                {
                    parameterConversions += $"{regHost}.ExcelParameterConversions.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[PARAMETER-CONVERSIONS]", parameterConversions);
            }
            {
                string returnConversions = "";
                foreach (var i in receiver.ReturnConversions)
                {
                    returnConversions += $"{regHost}.ExcelReturnConversions.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[RETURN-CONVERSIONS]", returnConversions);
            }
            {
                string executionHandlers = "";
                foreach (var i in receiver.ExecutionHandlers)
                {
                    executionHandlers += $"{regHost}.ExcelFunctionExecutionHandlerSelectors.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[EXECUTION-HANDLERS]", executionHandlers);
            }
            source = source.Replace("[DIRECT-MARSHAL-TYPE-ADAPTER]", CreateDirectMarshalTypeAdapter(receiver.Functions, receiver.Commands));

            context.AddSource($"ExcelDna.SG.NAOT.Init.g.cs", source);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        private static string GetMethod(IMethodSymbol method)
        {
            return $"typeof({Util.GetFullTypeName(method.ContainingType)}).GetMethod(\"{method.Name}\")!";
        }

        private static string CreateDirectMarshalTypeAdapter(List<IMethodSymbol> functions, List<IMethodSymbol> commands)
        {
            return """
                class DirectMarshalTypeAdapter : ExcelDna.Registration.StaticRegistration.IDirectMarshalTypeAdapter
                {
                    private class XlDirectMarshalLazy
                    {
                        readonly Lazy<Delegate> _delegate;

                        public XlDirectMarshalLazy(Func<Delegate> delegateFactory)
                        {
                            _delegate = new Lazy<Delegate>(delegateFactory, LazyThreadSafetyMode.PublicationOnly);
                        }
                    
                        public void Act0() => ((XlAct0)_delegate.Value)();

                        public IntPtr Func0() => ((XlFunc0)_delegate.Value)();
                        public IntPtr Func1(IntPtr p1) => ((XlFunc1)_delegate.Value)(p1);
                        public IntPtr Func2(IntPtr p1, IntPtr p2) => ((XlFunc2)_delegate.Value)(p1, p2);
                        public IntPtr Func16(IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11, IntPtr p12, IntPtr p13, IntPtr p14, IntPtr p15, IntPtr p16) => ((XlFunc16)_delegate.Value)(p1, p2, p3, p4, p5, p6, p7, p8, p9, p10, p11, p12, p13, p14, p15, p16);
                    }

                    public nint GetActionPointerForDelegate(Delegate d, int parameters)
                    {
                        switch (parameters)
                        {
                            case 0:
                                return Marshal.GetFunctionPointerForDelegate<XlAct0>((XlAct0)d);
                        }
                
                        throw new NotImplementedException($"GetActionPointerForDelegate {parameters}");
                    }

                    public Type GetActionType(int parameters)
                    {
                        switch (parameters)
                        {
                            case 0:
                                return typeof(XlAct0);
                         }
                
                        throw new NotImplementedException($"GetActionType {parameters}");
                    }

                    public nint GetFunctionPointerForDelegate(Delegate d, int parameters)
                    {
                        switch (parameters)
                        {
                            case 0:
                                return Marshal.GetFunctionPointerForDelegate<XlFunc0>((XlFunc0)d);
                            case 1:
                                return Marshal.GetFunctionPointerForDelegate<XlFunc1>((XlFunc1)d);
                            case 2:
                                return Marshal.GetFunctionPointerForDelegate<XlFunc2>((XlFunc2)d);
                            case 16:
                                return Marshal.GetFunctionPointerForDelegate<XlFunc16>((XlFunc16)d);
                        }

                        throw new NotImplementedException($"GetFunctionPointerForDelegate {parameters}");
                    }

                    public Type GetFunctionType(int parameters)
                    {
                        switch (parameters)
                        {
                            case 0:
                                return typeof(XlFunc0);
                            case 1:
                                return typeof(XlFunc1);
                            case 2:
                                return typeof(XlFunc2);
                            case 16:
                                return typeof(XlFunc16);
                         }

                        throw new NotImplementedException($"GetFunctionType {parameters}");
                    }

                    public Delegate CreateActionDelegate(Func<Delegate> delegateFactory, int parameters)
                    {
                        var lazyLambda = new XlDirectMarshalLazy(delegateFactory);
                        var delegateType = GetActionType(parameters);
                        var method = GetLazyAct(parameters);
                        return Delegate.CreateDelegate(delegateType, lazyLambda, method);
                    }

                    public Delegate CreateFunctionDelegate(Func<Delegate> delegateFactory, int parameters)
                    {
                        var lazyLambda = new XlDirectMarshalLazy(delegateFactory);
                        var delegateType = GetFunctionType(parameters);
                        var method = GetLazyFunc(parameters);
                        return Delegate.CreateDelegate(delegateType, lazyLambda, method);
                    }

                    private MethodInfo GetLazyAct(int parameters)
                    {
                        return typeof(XlDirectMarshalLazy).GetMethod("Act0");
                    }

                    private MethodInfo GetLazyFunc(int parameters)
                    {
                        switch (parameters)
                        {
                            case 0:
                                return typeof(XlDirectMarshalLazy).GetMethod("Func0");
                            case 1:
                                return typeof(XlDirectMarshalLazy).GetMethod("Func1");
                            case 2:
                                return typeof(XlDirectMarshalLazy).GetMethod("Func2");
                            case 16:
                                return typeof(XlDirectMarshalLazy).GetMethod("Func16");                         }

                        throw new NotImplementedException($"GetLazyFunc {parameters}");
                    }

                    private delegate void XlAct0();

                    private delegate IntPtr XlFunc0();
                    private delegate IntPtr XlFunc1(IntPtr p1);
                    private delegate IntPtr XlFunc2(IntPtr p1, IntPtr p2);
                    private delegate IntPtr XlFunc16(IntPtr p1, IntPtr p2, IntPtr p3, IntPtr p4, IntPtr p5, IntPtr p6, IntPtr p7, IntPtr p8, IntPtr p9, IntPtr p10, IntPtr p11, IntPtr p12, IntPtr p13, IntPtr p14, IntPtr p15, IntPtr p16);
                }
                """;
        }

        class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<IMethodSymbol> Functions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> Commands { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ParameterConversions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ReturnConversions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ExecutionHandlers { get; } = new List<IMethodSymbol>();
            public List<TypeInfo> AddIns { get; } = new List<TypeInfo>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if (context.Node is MethodDeclarationSyntax methodSyntax)
                {
                    IMethodSymbol methodSymbol = (context.SemanticModel.GetDeclaredSymbol(methodSyntax) as IMethodSymbol)!;
                    if (methodSymbol.ContainingType.DeclaredAccessibility == Accessibility.Public && methodSymbol.DeclaredAccessibility == Accessibility.Public && methodSymbol.IsStatic)
                    {
                        if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelFunctionAttribute"))
                        {
                            Functions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelCommandAttribute"))
                        {
                            Commands.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelParameterConversionAttribute"))
                        {
                            ParameterConversions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelReturnConversionAttribute"))
                        {
                            ReturnConversions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelFunctionExecutionHandlerSelectorAttribute"))
                        {
                            ExecutionHandlers.Add(methodSymbol);
                        }
                    }
                }

                if (context.Node is ClassDeclarationSyntax classSyntax)
                {
                    if (context.SemanticModel.GetDeclaredSymbol(classSyntax) is ITypeSymbol typeSymbol)
                    {
                        if (typeSymbol.AllInterfaces.Any(i => Util.GetFullTypeName(i) == "ExcelDna.Integration.IExcelAddIn" || Util.GetFullTypeName(i) == "ExcelDna.Integration.CustomUI.IExcelRibbon"))
                        {
                            AddIns.Add(new TypeInfo(typeSymbol, typeSymbol.GetMembers().OfType<IMethodSymbol>()));
                        }
                    }
                }
            }

            private static bool HasCustomAttribute(IMethodSymbol methodSymbol, string attribute)
            {
                return methodSymbol.GetAttributes().Any(a => a.AttributeClass != null &&
                        Util.TypeHasAncestorWithFullName(a.AttributeClass, attribute));
            }
        }
    }
}
