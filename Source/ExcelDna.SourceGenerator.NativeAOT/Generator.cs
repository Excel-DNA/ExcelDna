using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace ExcelDna.SourceGenerator.NativeAOT
{
    [Generator]
    public class Generator : ISourceGenerator
    {
        class TypeInfo
        {
            public ITypeSymbol Type { get; }
            public IEnumerable<IMethodSymbol> Methods { get; }

            public TypeInfo(ITypeSymbol type, IEnumerable<IMethodSymbol> methods)
            {
                this.Type = type;
                this.Methods = methods;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.PublishAOT", out string? publishAOT);

            const string regHost = "ExcelDna.Registration.StaticRegistration";
            string source = """
// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#nullable enable

namespace ExcelDna.SourceGenerator.NativeAOT
{
    public unsafe class AddInInitialize
    {
        [UnmanagedCallersOnly(EntryPoint = "Initialize", CallConvs = new[] { typeof(CallConvCdecl) })]
        public static short Initialize(void* xlAddInExportInfoAddress, void* hModuleXll, void* pPathXLL, byte disableAssemblyContextUnload, void* pTempDirPath)
        {
            [ADDINS]

[FUNCTIONS]

[ASSEMBLY-ATTRIBUTES]

[PARAMETER-CONVERSIONS]

[RETURN-CONVERSIONS]

[EXECUTION-HANDLERS]

            ExcelDna.Registration.StaticRegistration.DirectMarshalTypeAdapter = new DirectMarshalTypeAdapter();

            return ExcelDna.ManagedHost.AddInInitialize.InitializeNativeAOT(xlAddInExportInfoAddress, hModuleXll, pPathXLL, disableAssemblyContextUnload, pTempDirPath, typeof(AddInInitialize).Assembly);
        }
    }
}
""";
            {
                string addIns = "";
                foreach (var i in receiver.AddIns)
                {
                    if (string.IsNullOrWhiteSpace(addIns))
                        addIns = "List<Type> interfaceRefs = new List<Type>();\r\n";

                    string actions = "";
                    foreach (var m in i.Methods)
                    {
                        if (actions.Length > 0)
                            actions += ",\r\n";
                        actions += $"typeof({Util.GetFullTypeName(m.ContainingType)}).GetMethod(\"{m.Name}\")!";
                    }

                    addIns += $"{regHost}.ExcelAddIns.Add(new ExcelDna.Integration.TypeHelper<{Util.GetFullTypeName(i.Type)}>([{actions}]));\r\n";
                    addIns += $"interfaceRefs.Add(typeof({Util.GetFullTypeName(i.Type)}).GetInterface(\"ExcelDna.Integration.IExcelAddIn\")!);\r\n";
                    addIns += $"interfaceRefs.Add(typeof({Util.GetFullTypeName(i.Type)}).GetInterface(\"ExcelDna.Integration.CustomUI.IExcelRibbon\")!);\r\n";
                }
                source = source.Replace("[ADDINS]", addIns);
            }
            {
                string functions = "List<Type> typeRefs = new List<Type>();\r\n";
                string methods = "List<MethodInfo> methodRefs = new List<MethodInfo>();\r\n";
                foreach (var i in receiver.Functions.Concat(receiver.Commands))
                {
                    functions += $"{regHost}.MethodsForRegistration.Add({GetMethod(i)});\r\n";
                    functions += $"typeRefs.Add(typeof({Util.MethodType(i)}));\r\n";
                    foreach (var p in i.Parameters)
                    {
                        functions += $"typeRefs.Add(typeof(Func<object, {Util.GetFullTypeName(p.Type)}>));\r\n";
                    }

                    if (Util.IsLastArrayParams(i))
                    {
                        var arrayType = (IArrayTypeSymbol)i.Parameters.Last().Type;

                        methods += $"methodRefs.Add(typeof(List<{Util.GetFullTypeName(arrayType.ElementType)}>).GetMethod(\"ToArray\")!);\r\n";
                        methods += $"methodRefs.Add(typeof(List<{Util.GetFullTypeName(arrayType.ElementType)}>).GetMethod(\"Add\")!);\r\n";
                        functions += $"typeRefs.Add(typeof(Func<{Util.CreateFunc16Args(i)}>));\r\n";
                    }

                    if (i.ReturnType is INamedTypeSymbol named && named.IsGenericType && Util.GetFullGenericTypeName(named) == "System.Threading.Tasks.Task")
                    {
                        methods += $"methodRefs.Add(typeof(ExcelDna.Integration.ExcelAsyncUtil).GetMethod(\"RunTask\")!.MakeGenericMethod(typeof({Util.GetFullTypeName(named.TypeArguments.First())})));\r\n";
                    }

                    functions += "\r\n";
                }
                source = source.Replace("[FUNCTIONS]", functions + methods);
            }
            {
                string assemblyAttributes = "";
                foreach (AttributeData a in context.Compilation.Assembly.GetAttributes())
                {
                    if (a.AttributeClass == null || a.ConstructorArguments.Length != 1)
                        continue;

                    if (a.ConstructorArguments[0].Value is ITypeSymbol arg)
                        assemblyAttributes += $"{regHost}.AssemblyAttributes.Add(new {Util.GetFullTypeName(a.AttributeClass)}(typeof({Util.GetFullTypeName(arg)})));\r\n";
                }

                source = source.Replace("[ASSEMBLY-ATTRIBUTES]", assemblyAttributes);
            }
            {
                string parameterConversions = "";
                foreach (var i in receiver.ParameterConversions)
                {
                    parameterConversions += $"{regHost}.ExcelParameterConversions.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[PARAMETER-CONVERSIONS]", parameterConversions);
            }
            {
                string returnConversions = "";
                foreach (var i in receiver.ReturnConversions)
                {
                    returnConversions += $"{regHost}.ExcelReturnConversions.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[RETURN-CONVERSIONS]", returnConversions);
            }
            {
                string executionHandlers = "";
                foreach (var i in receiver.ExecutionHandlers)
                {
                    executionHandlers += $"{regHost}.ExcelFunctionExecutionHandlerSelectors.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[EXECUTION-HANDLERS]", executionHandlers);
            }
            context.AddSource($"ExcelDna.SG.NAOT.Init.g.cs", source);
            context.AddSource($"ExcelDna.SG.NAOT.Marshal.g.cs", MarshalGenerator.GenerateFile(receiver.Functions, receiver.Commands));
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        private static string GetMethod(IMethodSymbol method)
        {
            return $"typeof({Util.GetFullTypeName(method.ContainingType)}).GetMethod(\"{method.Name}\")!";
        }

        class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<IMethodSymbol> Functions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> Commands { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ParameterConversions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ReturnConversions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ExecutionHandlers { get; } = new List<IMethodSymbol>();
            public List<TypeInfo> AddIns { get; } = new List<TypeInfo>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if (context.Node is MethodDeclarationSyntax methodSyntax)
                {
                    IMethodSymbol methodSymbol = (context.SemanticModel.GetDeclaredSymbol(methodSyntax) as IMethodSymbol)!;
                    if (methodSymbol.ContainingType.DeclaredAccessibility == Accessibility.Public && methodSymbol.DeclaredAccessibility == Accessibility.Public && methodSymbol.IsStatic)
                    {
                        if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelFunctionAttribute"))
                        {
                            Functions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelCommandAttribute"))
                        {
                            Commands.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelParameterConversionAttribute"))
                        {
                            ParameterConversions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelReturnConversionAttribute"))
                        {
                            ReturnConversions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelFunctionExecutionHandlerSelectorAttribute"))
                        {
                            ExecutionHandlers.Add(methodSymbol);
                        }
                    }
                }

                if (context.Node is ClassDeclarationSyntax classSyntax)
                {
                    if (context.SemanticModel.GetDeclaredSymbol(classSyntax) is ITypeSymbol typeSymbol)
                    {
                        if (typeSymbol.AllInterfaces.Any(i => Util.GetFullTypeName(i) == "ExcelDna.Integration.IExcelAddIn" || Util.GetFullTypeName(i) == "ExcelDna.Integration.CustomUI.IExcelRibbon"))
                        {
                            AddIns.Add(new TypeInfo(typeSymbol, typeSymbol.GetMembers().OfType<IMethodSymbol>()));
                        }
                    }
                }
            }

            private static bool HasCustomAttribute(IMethodSymbol methodSymbol, string attribute)
            {
                return methodSymbol.GetAttributes().Any(a => a.AttributeClass != null &&
                        Util.TypeHasAncestorWithFullName(a.AttributeClass, attribute));
            }
        }
    }
}
