using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System;
using System.Collections.Generic;
using System.Linq;

namespace ExcelDna.SourceGenerator.NativeAOT
{
    [Generator]
    public class Generator : ISourceGenerator
    {
        class TypeInfo
        {
            public ITypeSymbol Type { get; }
            public IEnumerable<IMethodSymbol> Methods { get; }

            public TypeInfo(ITypeSymbol type, IEnumerable<IMethodSymbol> methods)
            {
                this.Type = type;
                this.Methods = methods;
            }
        }

        public void Execute(GeneratorExecutionContext context)
        {
            if (!(context.SyntaxContextReceiver is SyntaxReceiver receiver))
                return;

            context.AnalyzerConfigOptions.GlobalOptions.TryGetValue("build_property.PublishAOT", out string? publishAOT);

            const string regHost = "ExcelDna.Registration.StaticRegistration";
            string source = """
// <auto-generated/>
using System;
using System.Collections.Generic;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

#nullable enable

namespace ExcelDna.SourceGenerator.NativeAOT
{
    public unsafe class AddInInitialize
    {
        [UnmanagedCallersOnly(EntryPoint = "Initialize", CallConvs = new[] { typeof(CallConvCdecl) })]
        public static short Initialize(void* xlAddInExportInfoAddress, void* hModuleXll, void* pPathXLL, byte disableAssemblyContextUnload, void* pTempDirPath)
        {
            ExcelDna.Integration.NativeAOT.IsActive = true;

            [ADDINS]

[FUNCTIONS]

[ASSEMBLY-ATTRIBUTES]

[PARAMETER-CONVERSIONS]

[RETURN-CONVERSIONS]

[EXECUTION-HANDLERS]

            return ExcelDna.ManagedHost.AddInInitialize.InitializeNativeAOT(xlAddInExportInfoAddress, hModuleXll, pPathXLL, disableAssemblyContextUnload, pTempDirPath);
        }
    }
}
""";
            {
                string addIns = "";
                foreach (var i in receiver.AddIns)
                {
                    string actions = "";
                    foreach (var m in i.Methods)
                    {
                        if (actions.Length > 0)
                            actions += ",\r\n";
                        actions += $"typeof({Util.GetFullTypeName(m.ContainingType)}).GetMethod(\"{m.Name}\")!";
                    }

                    addIns += $"{regHost}.ExcelAddIns.Add(new ExcelDna.Integration.TypeHelper<{Util.GetFullTypeName(i.Type)}>([{actions}]));\r\n";
                }
                source = source.Replace("[ADDINS]", addIns);
            }
            {
                string functions = "List<Type> typeRefs = new List<Type>();\r\n";
                string methods = "List<MethodInfo> methodRefs = new List<MethodInfo>();\r\n";
                foreach (var i in receiver.Functions)
                {
                    functions += $"{regHost}.MethodsForRegistration.Add({GetMethod(i)});\r\n";
                    functions += $"typeRefs.Add(typeof({Util.MethodType(i)}));\r\n";
                    foreach (var p in i.Parameters)
                    {
                        functions += $"typeRefs.Add(typeof(Func<object, {Util.GetFullTypeName(p.Type)}>));\r\n";
                    }

                    if (i.Parameters.Length > 0 && i.Parameters.Last().IsParams && i.Parameters.Last().Type is IArrayTypeSymbol arrayType)
                    {
                        methods += $"methodRefs.Add(typeof(List<{Util.GetFullTypeName(arrayType.ElementType)}>).GetMethod(\"ToArray\")!);\r\n";
                        functions += $"typeRefs.Add(typeof(Func<{Util.CreateFunc16Args(i)}>));\r\n";
                    }

                    functions += "\r\n";
                }
                source = source.Replace("[FUNCTIONS]", functions + methods);
            }
            {
                string assemblyAttributes = "";
                foreach (AttributeData a in context.Compilation.Assembly.GetAttributes())
                {
                    if (a.AttributeClass == null || a.ConstructorArguments.Length != 1)
                        continue;

                    if (a.ConstructorArguments[0].Value is ITypeSymbol arg)
                        assemblyAttributes += $"{regHost}.AssemblyAttributes.Add(new {Util.GetFullTypeName(a.AttributeClass)}(typeof({Util.GetFullTypeName(arg)})));\r\n";
                }

                source = source.Replace("[ASSEMBLY-ATTRIBUTES]", assemblyAttributes);
            }
            {
                string parameterConversions = "";
                foreach (var i in receiver.ParameterConversions)
                {
                    parameterConversions += $"{regHost}.ExcelParameterConversions.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[PARAMETER-CONVERSIONS]", parameterConversions);
            }
            {
                string returnConversions = "";
                foreach (var i in receiver.ReturnConversions)
                {
                    returnConversions += $"{regHost}.ExcelReturnConversions.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[RETURN-CONVERSIONS]", returnConversions);
            }
            {
                string executionHandlers = "";
                foreach (var i in receiver.ExecutionHandlers)
                {
                    executionHandlers += $"{regHost}.ExcelFunctionExecutionHandlerSelectors.Add({GetMethod(i)});\r\n";
                }

                source = source.Replace("[EXECUTION-HANDLERS]", executionHandlers);
            }

            context.AddSource($"ExcelDna.SG.NAOT.Init.g.cs", source);
        }

        public void Initialize(GeneratorInitializationContext context)
        {
            context.RegisterForSyntaxNotifications(() => new SyntaxReceiver());
        }

        private static string GetMethod(IMethodSymbol method)
        {
            return $"typeof({Util.GetFullTypeName(method.ContainingType)}).GetMethod(\"{method.Name}\")!";
        }

        class SyntaxReceiver : ISyntaxContextReceiver
        {
            public List<IMethodSymbol> Functions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ParameterConversions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ReturnConversions { get; } = new List<IMethodSymbol>();
            public List<IMethodSymbol> ExecutionHandlers { get; } = new List<IMethodSymbol>();
            public List<TypeInfo> AddIns { get; } = new List<TypeInfo>();

            public void OnVisitSyntaxNode(GeneratorSyntaxContext context)
            {
                if (context.Node is MethodDeclarationSyntax methodSyntax)
                {
                    IMethodSymbol methodSymbol = (context.SemanticModel.GetDeclaredSymbol(methodSyntax) as IMethodSymbol)!;
                    if (methodSymbol.ContainingType.DeclaredAccessibility == Accessibility.Public && methodSymbol.DeclaredAccessibility == Accessibility.Public && methodSymbol.IsStatic)
                    {
                        if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelFunctionAttribute") || HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelCommandAttribute"))
                        {
                            Functions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelParameterConversionAttribute"))
                        {
                            ParameterConversions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelReturnConversionAttribute"))
                        {
                            ReturnConversions.Add(methodSymbol);
                        }
                        else if (HasCustomAttribute(methodSymbol, "ExcelDna.Integration.ExcelFunctionExecutionHandlerSelectorAttribute"))
                        {
                            ExecutionHandlers.Add(methodSymbol);
                        }
                    }
                }

                if (context.Node is ClassDeclarationSyntax classSyntax)
                {
                    if (context.SemanticModel.GetDeclaredSymbol(classSyntax) is ITypeSymbol typeSymbol)
                    {
                        if (typeSymbol.AllInterfaces.Any(i => Util.GetFullTypeName(i) == "ExcelDna.Integration.IExcelAddIn" || Util.GetFullTypeName(i) == "ExcelDna.Integration.CustomUI.IExcelRibbon"))
                        {
                            AddIns.Add(new TypeInfo(typeSymbol, typeSymbol.GetMembers().OfType<IMethodSymbol>()));
                        }
                    }
                }
            }

            private static bool HasCustomAttribute(IMethodSymbol methodSymbol, string attribute)
            {
                return methodSymbol.GetAttributes().Any(a => a.AttributeClass != null &&
                        Util.TypeHasAncestorWithFullName(a.AttributeClass, attribute));
            }
        }
    }
}
